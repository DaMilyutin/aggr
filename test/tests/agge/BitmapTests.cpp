#include <agge/bitmap.h>

#include "helpers.h"
#include "mocks.h"

#include <vector>

#include <ut/assert.h>
#include <ut/test.h>

using namespace std;

namespace agge
{
	namespace tests
	{
		namespace
		{
			uint8_t c_small_pattern[] = {
				0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
				0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11,
				0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11,
				0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11,
				0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
			};
		}

		namespace mocks
		{
			class raw_bitmap
			{
			public:
				raw_bitmap(count_t width, count_t height, bits_per_pixel bpp, count_t row_extra_bytes)
					: data(width * height * ((int)bpp / 8)), extra_bytes(row_extra_bytes), _width(width), _height(height),
						_bpp(bpp)
				{	}

				count_t width() const
				{	return _width;	}

				count_t height() const
				{	return _height;	}

				bits_per_pixel bpp() const
				{	return _bpp;	}

				void *row_ptr(count_t y)
				{	return &data[y * _width * ((int)_bpp / 8)];	}

				const void *row_ptr(count_t y) const
				{	return &data[y * _width * ((int)_bpp / 8)];	}

				vector<uint8_t> data;
				count_t extra_bytes;

			public:
				count_t _width, _height;
				bits_per_pixel _bpp;
			};
		}

		begin_test_suite( BitmapTests )
			test( WidthAndHeightArePassedThroughToRawBitmapOnCreation )
			{
				// INIT / ACT
				bitmap<pixel32, mocks::raw_bitmap> b1(640, 480);
				bitmap<pixel32, mocks::raw_bitmap> b2(1200, 800);
				bitmap<pixel32, mocks::raw_bitmap> b3(640, 480, 15);
				bitmap<uint8_t, mocks::raw_bitmap> b4(1200, 800, 7);

				// ASSERT
				assert_equal(640u, static_cast<mocks::raw_bitmap &>(b1).width());
				assert_equal(480u, static_cast<mocks::raw_bitmap &>(b1).height());
				assert_equal(16u, b1.extra_bytes);
				assert_equal(1200u, b2.width());
				assert_equal(800u, b2.height());
				assert_equal(16u, b2.extra_bytes);
				assert_equal(640u, b3.width());
				assert_equal(480u, b3.height());
				assert_equal(15u, b3.extra_bytes);
				assert_equal(1200u, b4.width());
				assert_equal(800u, b4.height());
				assert_equal(7u, b4.extra_bytes);
			}

			
			test( ProperBPPIsPassedToConstructor )
			{
				// INIT / ACT
				bitmap<pixel32, mocks::raw_bitmap> b1(10, 10);
				bitmap<pixel24, mocks::raw_bitmap> b2(10, 10);
				bitmap<pixel16, mocks::raw_bitmap> b3(10, 10);
				bitmap<uint8_t, mocks::raw_bitmap> b4(10, 10);

				// ASSERT
				assert_equal(bpp32, static_cast<mocks::raw_bitmap &>(b1).bpp());
				assert_equal(bpp24, b2.bpp());
				assert_equal(bpp16, b3.bpp());
				assert_equal(bpp8, b4.bpp());
			}


			test( RowPtrIsRepresentedWithPixelPointer )
			{
				// INIT
				typedef bitmap<pixel32, mocks::raw_bitmap> bitmap32;
				typedef bitmap<pixel24, mocks::raw_bitmap> bitmap24;

				bitmap32 b1(10, 10);
				bitmap24 b2(10, 10);

				// ACT
				pixel32 *p1 = static_cast<bitmap32::pixel *>(b1.row_ptr(3));
				pixel32 *p2 = b1.row_ptr(4);
				pixel24 *p3 = static_cast<bitmap24::pixel *>(b2.row_ptr(7));
				pixel24 *p4 = b2.row_ptr(1);

				// ASSERT
				assert_equal(p1, static_cast<mocks::raw_bitmap &>(b1).row_ptr(3));
				assert_equal(p2, static_cast<mocks::raw_bitmap &>(b1).row_ptr(4));
				assert_equal(p3, static_cast<mocks::raw_bitmap &>(b2).row_ptr(7));
				assert_equal(p4, static_cast<mocks::raw_bitmap &>(b2).row_ptr(1));
			}


			test( ConstRowPtrIsRepresentedWithPixelPointer )
			{
				// INIT
				typedef bitmap<pixel32, mocks::raw_bitmap> bitmap32;
				typedef bitmap<pixel24, mocks::raw_bitmap> bitmap24;

				const bitmap32 b1(10, 10);
				const bitmap24 b2(10, 10);

				// ACT
				const pixel32 *p1 = static_cast<const bitmap32::pixel *>(b1.row_ptr(3));
				const pixel32 *p2 = b1.row_ptr(4);
				const pixel24 *p3 = static_cast<const bitmap24::pixel *>(b2.row_ptr(7));
				const pixel24 *p4 = b2.row_ptr(1);

				// ASSERT
				assert_equal(p1, static_cast<const mocks::raw_bitmap &>(b1).row_ptr(3));
				assert_equal(p2, static_cast<const mocks::raw_bitmap &>(b1).row_ptr(4));
				assert_equal(p3, static_cast<const mocks::raw_bitmap &>(b2).row_ptr(7));
				assert_equal(p4, static_cast<const mocks::raw_bitmap &>(b2).row_ptr(1));
			}


			test( BitmapCopyCopiesPixelsRowWise )
			{
				// INIT
				typedef bitmap<pixel32, mocks::raw_bitmap> bitmap;
				
				bitmap source(4, 5);
				mocks::bitmap<pixel32, 0> destination(5, 6);
				const bitmap &csource = source;
				uint8_t data[] = {
					0xFF,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
					0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0xFF,0x00,0x00, 0x00,0x00,0x00,0x00,
					0x00,0x00,0x00,0xFF, 0x00,0xCE,0xFF,0x00, 0xFF,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
					0x00,0x00,0xFF,0x00, 0x00,0x00,0x00,0xFF, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
					0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0xFF,0x00,0x00,0xFF,
				};

				source.data = mkvector(data);
				destination.data[4].components[0] = 0xCD;
				destination.data[9].components[1] = 0xCD;

				// ACT
				copy(csource, 0, 0, destination, 0, 0, 4, 5);

				// ASSERT
				pixel32 reference[] = {
					{ { 0xFF,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0xCD,0x00,0x00,0x00 } },
					{ { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0x00,0xFF,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0x00,0xCD,0x00,0x00 } },
					{ { 0x00,0x00,0x00,0xFF } }, { { 0x00,0xCE,0xFF,0x00 } }, { { 0xFF,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } },
					{ { 0x00,0x00,0xFF,0x00 } }, { { 0x00,0x00,0x00,0xFF } }, { { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } },
					{ { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0xFF,0x00,0x00,0xFF } }, { { 0x00,0x00,0x00,0x00 } },
					{ { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } }, { { 0x00,0x00,0x00,0x00 } },
				};

				assert_equal(reference, destination.data);
			}


			test( CopyingPixelsObeysSourceBitmapBounds )
			{
				// INIT
				typedef bitmap<uint8_t, mocks::raw_bitmap> bitmap;
				
				bitmap source(7, 5);
				mocks::bitmap<uint8_t, 0> destination(12, 8);

				source.data = mkvector(c_small_pattern);

				// ACT
				copy(source, 0, 0, destination, 0, 0, 1000, 1000);

				// ASSERT
				uint8_t reference[] = {
					0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				};

				assert_equal(reference, destination.data);
			}


			test( CopyingPixelsObeysRequestedBounds )
			{
				// INIT
				typedef bitmap<uint8_t, mocks::raw_bitmap> bitmap;
				
				bitmap source(7, 5);
				mocks::bitmap<uint8_t, 0> destination(8, 6);

				source.data = mkvector(c_small_pattern);

				// ACT
				copy(source, 0, 0, destination, 0, 0, 6, 3);

				// ASSERT
				uint8_t reference[] = {
					0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00,
					0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
					0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				};

				assert_equal(reference, destination.data);
			}


			test( CopyingPixelsObeysDestinationBounds )
			{
				// INIT
				typedef bitmap<uint8_t, mocks::raw_bitmap> bitmap;
				
				bitmap source(7, 5);
				mocks::bitmap<uint8_t, 1> destination(3, 4);
				
				destination.data.resize(destination.data.size() + 4);

				source.data = mkvector(c_small_pattern);

				// ACT
				copy(source, 0, 0, destination, 0, 0, 100, 70);

				// ASSERT
				uint8_t reference[] = {
					0x11, 0x11, 0x11, 0x00,
					0x11, 0xFF, 0xFF, 0x00,
					0x11, 0xFF, 0xFF, 0x00,
					0x11, 0xFF, 0xFF, 0x00,
					0x00, 0x00, 0x00, 0x00,
				};

				assert_equal(reference, destination.data);
			}


			test( PixelsAreShiftedAndBoundAccordinglyToDestinationPosition )
			{
				// INIT
				typedef bitmap<uint8_t, mocks::raw_bitmap> bitmap;
				
				bitmap source(7, 5);
				mocks::bitmap<uint8_t, 1> destination(12, 7);

				destination.data.resize(destination.data.size() + 13);
				source.data = mkvector(c_small_pattern);

				// ACT
				copy(source, 0, 0, destination, 3, 1, 1000, 1000);

				// ASSERT
				uint8_t reference1[] = {
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				};

				assert_equal(reference1, destination.data);

				// ACT
				copy(source, 0, 0, destination, 2, 2, 1000, 1000);

				// ASSERT
				uint8_t reference2[] = {
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x11, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x11, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x11, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				};

				assert_equal(reference2, destination.data);

				// INIT
				destination.data.assign(destination.data.size(), 0);

				// ACT
				copy(source, 0, 0, destination, 8, 4, 1000, 1000);

				// ASSERT
				uint8_t reference3[] = {
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xFF, 0xFF, 0xFF, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xFF, 0xFF, 0xFF, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				};

				assert_equal(reference3, destination.data);
			}


			test( PixelsAreShiftedAndBoundAccordinglyToSourcePosition )
			{
				// INIT
				typedef bitmap<uint8_t, mocks::raw_bitmap> bitmap;
				
				bitmap source(7, 5);
				mocks::bitmap<uint8_t, 1> destination(11, 7);

				destination.data.resize(destination.data.size() + 12);
				source.data = mkvector(c_small_pattern);

				// ACT
				copy(source, 2, 1, destination, 1, 1, 1000, 1000);

				// ASSERT
				uint8_t reference[] = {
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				};

				assert_equal(reference, destination.data);
			}


			test( NegativeCoordinatesAreTrimmedToZeroOnCopy )
			{
				// INIT
				typedef bitmap<uint8_t, mocks::raw_bitmap> bitmap;
				
				bitmap source(7, 5);
				mocks::bitmap<uint8_t, 0> destination(8, 7);

				source.data = mkvector(c_small_pattern);

				// ACT
				copy(source, -2, -1, destination, 0, 0, 7, 5);

				// ASSERT
				uint8_t reference1[] = {
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00,
					0x00, 0x00, 0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
					0x00, 0x00, 0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
					0x00, 0x00, 0x11, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				};

				assert_equal(reference1, destination.data);

				// INIT
				destination.data.assign(destination.data.size(), 0x07);

				// ACT
				copy(source, -3, -2, destination, 0, 0, 6, 4);

				// ASSERT
				uint8_t reference2[] = {
					0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
					0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
					0x07, 0x07, 0x07, 0x11, 0x11, 0x11, 0x07, 0x07,
					0x07, 0x07, 0x07, 0x11, 0xFF, 0xFF, 0x07, 0x07,
					0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
					0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
					0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
				};

				assert_equal(reference2, destination.data);

				// INIT
				destination.data.assign(destination.data.size(), 0x00);

				// ACT
				copy(source, 0, 0, destination, -1, -2, 6, 4);

				// ASSERT
				uint8_t reference3[] = {
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				};

				assert_equal(reference3, destination.data);

				// INIT
				destination.data.assign(destination.data.size(), 0x00);

				// ACT
				copy(source, 0, 0, destination, -3, -1, 7, 5);

				// ASSERT
				uint8_t reference4[] = {
					0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00, 0x00,
					0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00, 0x00,
					0xFF, 0xFF, 0xFF, 0x11, 0x00, 0x00, 0x00, 0x00,
					0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				};

				assert_equal(reference4, destination.data);
			}

		end_test_suite
	}
}
